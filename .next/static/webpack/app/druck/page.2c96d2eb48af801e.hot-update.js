"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/druck/page",{

/***/ "(app-pages-browser)/./src/lib/pdf-generator.ts":
/*!**********************************!*\
  !*** ./src/lib/pdf-generator.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generatePDF: function() { return /* binding */ generatePDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var _data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/data/paper-sizes.json */ \"(app-pages-browser)/./src/data/paper-sizes.json\");\n/* harmony import */ var _config_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/config/settings */ \"(app-pages-browser)/./src/config/settings.ts\");\n/* harmony import */ var _data_fonts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/data/fonts */ \"(app-pages-browser)/./src/data/fonts.ts\");\n// !!! WICHTIG: Diese Datei ist essentiell für die PDF-Generierung und darf nicht gelöscht werden !!!\n// !!! Sie enthält die Logik für die Erstellung der PDF-Dokumente mit allen Einstellungen !!!\n\n\n\n\n// Konvertiert Hex-Farbe in RGB\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : {\n        r: 255,\n        g: 255,\n        b: 255\n    };\n}\n// Konvertiere ArrayBuffer zu Base64\nfunction arrayBufferToBase64(buffer) {\n    let binary = \"\";\n    const bytes = new Uint8Array(buffer);\n    for(let i = 0; i < bytes.byteLength; i++){\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n// Registriere die Schriftarten für jsPDF\nasync function registerFonts(pdf) {\n    for (const font of _data_fonts__WEBPACK_IMPORTED_MODULE_3__.fonts){\n        try {\n            // Lade die Regular-Version als Standardschrift\n            const regularWeight = font.weights.find((w)=>w.value === 400) || font.weights[0];\n            const fontPath = \"\".concat(font.path, \"/\").concat(regularWeight.file);\n            console.log(\"Lade Schriftart:\", fontPath);\n            const response = await fetch(fontPath);\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const fontBuffer = await response.arrayBuffer();\n            const fontBase64 = arrayBufferToBase64(fontBuffer);\n            // Registriere die Basisschrift\n            pdf.addFileToVFS(\"\".concat(font.family, \".ttf\"), fontBase64);\n            pdf.addFont(\"\".concat(font.family, \".ttf\"), font.family, \"normal\");\n            // Lade zusätzliche Gewichte\n            for (const weight of font.weights){\n                if (weight.value !== 400) {\n                    const weightPath = \"\".concat(font.path, \"/\").concat(weight.file);\n                    const weightResponse = await fetch(weightPath);\n                    if (weightResponse.ok) {\n                        const weightBuffer = await weightResponse.arrayBuffer();\n                        const weightBase64 = arrayBufferToBase64(weightBuffer);\n                        const weightStyle = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.weightMapping[weight.value];\n                        pdf.addFileToVFS(\"\".concat(font.family, \"-\").concat(weightStyle, \".ttf\"), weightBase64);\n                        pdf.addFont(\"\".concat(font.family, \"-\").concat(weightStyle, \".ttf\"), font.family, weightStyle);\n                    }\n                }\n            }\n            console.log(\"Schriftart erfolgreich geladen:\", font.family);\n        } catch (error) {\n            console.error(\"Fehler beim Laden der Schriftart:\", font.family, error);\n        }\n    }\n}\n// Setzt die Textstile für das PDF\nfunction applyTextStyle(pdf, block) {\n    try {\n        // Verwende die tatsächliche Schriftart\n        const fontFamily = block.fontFamily;\n        const fontWeight = typeof block.fontWeight === \"string\" ? parseInt(block.fontWeight) : block.fontWeight;\n        const fontStyle = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.weightMapping[fontWeight] || \"normal\";\n        // Setze die Schriftart\n        pdf.setFont(fontFamily, fontStyle);\n        // Schriftgrößenberechnung mit Skalierungsfaktor\n        const fontSize = Math.round(block.fontSize * _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.fontScaleFactor);\n        pdf.setFontSize(fontSize);\n        // Setze die Textfarbe\n        const textColor = hexToRgb(block.color);\n        pdf.setTextColor(textColor.r, textColor.g, textColor.b);\n        // Setze den Buchstabenabstand, falls vorhanden\n        if (block.letterSpacing) {\n            pdf.setCharSpace(block.letterSpacing);\n        }\n        // Setze die Zeilenhöhe, falls vorhanden\n        if (block.lineHeight) {\n            pdf.setLineHeightFactor(block.lineHeight);\n        }\n    } catch (error) {\n        console.error(\"Fehler beim Anwenden der Textstile:\", error);\n        // Fallback zu Standard-Schriftart\n        pdf.setFont(\"helvetica\", \"normal\");\n    }\n}\n// Berechnet die Position für den Text\nfunction calculateTextPosition(block, pageWidth, pageHeight) {\n    return {\n        x: block.x / 100 * pageWidth,\n        y: block.y / 100 * pageHeight\n    };\n}\n// Rendert einen Textblock im PDF\nfunction renderTextBlock(pdf, block, pageWidth, pageHeight) {\n    // Wende Textstile an\n    applyTextStyle(pdf, block);\n    // Berechne Position\n    const { x, y } = calculateTextPosition(block, pageWidth, pageHeight);\n    // Text einfügen\n    pdf.text(block.text, x, y, {\n        align: \"center\",\n        baseline: \"middle\",\n        maxWidth: pageWidth - _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.minMargin * 2\n    });\n}\nasync function generatePDF(options) {\n    // Finde die ausgewählte Papiergröße\n    const allSizes = [\n        ..._data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__.poster.portrait,\n        ..._data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__.poster.landscape\n    ];\n    const selectedSize = allSizes.find((size)=>size.id === options.pageSize);\n    if (!selectedSize) {\n        throw new Error(\"Ung\\xfcltige Papiergr\\xf6\\xdfe\");\n    }\n    // Extrahiere die Maße\n    const { width, height } = selectedSize;\n    const orientation = options.pageSize.startsWith(\"l\") ? \"landscape\" : \"portrait\";\n    const { bleed } = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings;\n    // Erstelle PDF\n    const pdf = new jspdf__WEBPACK_IMPORTED_MODULE_0__.jsPDF({\n        orientation,\n        unit: \"mm\",\n        format: [\n            width + bleed * 2,\n            height + bleed * 2\n        ]\n    });\n    // Registriere die Schriftarten\n    await registerFonts(pdf);\n    // Setze Hintergrundfarbe\n    const bgColor = hexToRgb(options.backgroundColor);\n    pdf.setFillColor(bgColor.r, bgColor.g, bgColor.b);\n    pdf.rect(0, 0, width + bleed * 2, height + bleed * 2, \"F\");\n    // Füge alle Textblöcke ein\n    const pageWidth = width + bleed * 2;\n    const pageHeight = height + bleed * 2;\n    options.content.forEach((block)=>{\n        renderTextBlock(pdf, block, pageWidth, pageHeight);\n    });\n    // PDF als Uint8Array zurückgeben\n    const arrayBuffer = pdf.output(\"arraybuffer\");\n    return new Uint8Array(arrayBuffer);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcGRmLWdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHFHQUFxRztBQUNyRyw2RkFBNkY7QUFFaEU7QUFDbUI7QUFFRDtBQUNYO0FBRXBDLCtCQUErQjtBQUMvQixTQUFTSSxTQUFTQyxHQUFXO0lBQzNCLE1BQU1DLFNBQVMsNENBQTRDQyxJQUFJLENBQUNGO0lBQ2hFLE9BQU9DLFNBQVM7UUFDZEUsR0FBR0MsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkksR0FBR0QsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkssR0FBR0YsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtJQUN6QixJQUFJO1FBQUVFLEdBQUc7UUFBS0UsR0FBRztRQUFLQyxHQUFHO0lBQUk7QUFDL0I7QUFFQSxvQ0FBb0M7QUFDcEMsU0FBU0Msb0JBQW9CQyxNQUFtQjtJQUM5QyxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsUUFBUSxJQUFJQyxXQUFXSDtJQUM3QixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUYsTUFBTUcsVUFBVSxFQUFFRCxJQUFLO1FBQ3pDSCxVQUFVSyxPQUFPQyxZQUFZLENBQUNMLEtBQUssQ0FBQ0UsRUFBRTtJQUN4QztJQUNBLE9BQU9JLEtBQUtQO0FBQ2Q7QUFFQSx5Q0FBeUM7QUFDekMsZUFBZVEsY0FBY0MsR0FBVTtJQUNyQyxLQUFLLE1BQU1DLFFBQVFyQiw4Q0FBS0EsQ0FBRTtRQUN4QixJQUFJO1lBQ0YsK0NBQStDO1lBQy9DLE1BQU1zQixnQkFBZ0JELEtBQUtFLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxLQUFLLEtBQUssUUFBUUwsS0FBS0UsT0FBTyxDQUFDLEVBQUU7WUFDaEYsTUFBTUksV0FBVyxHQUFnQkwsT0FBYkQsS0FBS08sSUFBSSxFQUFDLEtBQXNCLE9BQW5CTixjQUFjTyxJQUFJO1lBQ25EQyxRQUFRQyxHQUFHLENBQUMs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Q0FBS0EsQ0FBQztRQUNwQitGO1FBQ0FHLE1BQU07UUFDTkMsUUFBUTtZQUNOTixRQUFTSSxRQUFRO1lBQ2pCSCxTQUFVRyxRQUFRO1NBQ25CO0lBQ0g7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTTNFLGNBQWNDO0lBRXBCLHlCQUF5QjtJQUN6QixNQUFNNkUsVUFBVWhHLFNBQVNnRixRQUFRaUIsZUFBZTtJQUNoRDlFLElBQUkrRSxZQUFZLENBQUNGLFFBQVE1RixDQUFDLEVBQUU0RixRQUFRMUYsQ0FBQyxFQUFFMEYsUUFBUXpGLENBQUM7SUFDaERZLElBQUlnRixJQUFJLENBQ04sR0FDQSxHQUNBVixRQUFTSSxRQUFRLEdBQ2pCSCxTQUFVRyxRQUFRLEdBQ2xCO0lBR0YsMkJBQTJCO0lBQzNCLE1BQU14QixZQUFZb0IsUUFBU0ksUUFBUTtJQUNuQyxNQUFNdkIsYUFBYW9CLFNBQVVHLFFBQVE7SUFFckNiLFFBQVFvQixPQUFPLENBQUNDLE9BQU8sQ0FBQ2xELENBQUFBO1FBQ3RCc0IsZ0JBQWdCdEQsS0FBS2dDLE9BQU9rQixXQUFXQztJQUN6QztJQUVBLGlDQUFpQztJQUNqQyxNQUFNakMsY0FBY2xCLElBQUltRixNQUFNLENBQUM7SUFDL0IsT0FBTyxJQUFJMUYsV0FBV3lCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcGRmLWdlbmVyYXRvci50cz84NmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICEhISBXSUNIVElHOiBEaWVzZSBEYXRlaSBpc3QgZXNzZW50aWVsbCBmw7xyIGRpZSBQREYtR2VuZXJpZXJ1bmcgdW5kIGRhcmYgbmljaHQgZ2Vsw7ZzY2h0IHdlcmRlbiAhISFcbi8vICEhISBTaWUgZW50aMOkbHQgZGllIExvZ2lrIGbDvHIgZGllIEVyc3RlbGx1bmcgZGVyIFBERi1Eb2t1bWVudGUgbWl0IGFsbGVuIEVpbnN0ZWxsdW5nZW4gISEhXG5cbmltcG9ydCB7IGpzUERGIH0gZnJvbSAnanNwZGYnXG5pbXBvcnQgcGFwZXJTaXplcyBmcm9tICdAL2RhdGEvcGFwZXItc2l6ZXMuanNvbidcbmltcG9ydCB7IFRleHRCbG9jayB9IGZyb20gJ0AvdHlwZXMvdGV4dCdcbmltcG9ydCB7IHBkZlNldHRpbmdzIH0gZnJvbSAnQC9jb25maWcvc2V0dGluZ3MnXG5pbXBvcnQgeyBmb250cyB9IGZyb20gJ0AvZGF0YS9mb250cydcblxuLy8gS29udmVydGllcnQgSGV4LUZhcmJlIGluIFJHQlxuZnVuY3Rpb24gaGV4VG9SZ2IoaGV4OiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGhleClcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDE2KVxuICB9IDogeyByOiAyNTUsIGc6IDI1NSwgYjogMjU1IH1cbn1cblxuLy8gS29udmVydGllcmUgQXJyYXlCdWZmZXIgenUgQmFzZTY0XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIpOiBzdHJpbmcge1xuICBsZXQgYmluYXJ5ID0gJyc7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbn1cblxuLy8gUmVnaXN0cmllcmUgZGllIFNjaHJpZnRhcnRlbiBmw7xyIGpzUERGXG5hc3luYyBmdW5jdGlvbiByZWdpc3RlckZvbnRzKHBkZjoganNQREYpIHtcbiAgZm9yIChjb25zdCBmb250IG9mIGZvbnRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExhZGUgZGllIFJlZ3VsYXItVmVyc2lvbiBhbHMgU3RhbmRhcmRzY2hyaWZ0XG4gICAgICBjb25zdCByZWd1bGFyV2VpZ2h0ID0gZm9udC53ZWlnaHRzLmZpbmQodyA9PiB3LnZhbHVlID09PSA0MDApIHx8IGZvbnQud2VpZ2h0c1swXTtcbiAgICAgIGNvbnN0IGZvbnRQYXRoID0gYCR7Zm9udC5wYXRofS8ke3JlZ3VsYXJXZWlnaHQuZmlsZX1gXG4gICAgICBjb25zb2xlLmxvZygnTGFkZSBTY2hyaWZ0YXJ0OicsIGZvbnRQYXRoKVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZvbnRQYXRoKVxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvbnRCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gICAgICBjb25zdCBmb250QmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChmb250QnVmZmVyKVxuICAgICAgXG4gICAgICAvLyBSZWdpc3RyaWVyZSBkaWUgQmFzaXNzY2hyaWZ0XG4gICAgICBwZGYuYWRkRmlsZVRvVkZTKGAke2ZvbnQuZmFtaWx5fS50dGZgLCBmb250QmFzZTY0KVxuICAgICAgcGRmLmFkZEZvbnQoYCR7Zm9udC5mYW1pbHl9LnR0ZmAsIGZvbnQuZmFtaWx5LCAnbm9ybWFsJylcbiAgICAgIFxuICAgICAgLy8gTGFkZSB6dXPDpHR6bGljaGUgR2V3aWNodGVcbiAgICAgIGZvciAoY29uc3Qgd2VpZ2h0IG9mIGZvbnQud2VpZ2h0cykge1xuICAgICAgICBpZiAod2VpZ2h0LnZhbHVlICE9PSA0MDApIHsgLy8gw5xiZXJzcHJpbmdlIFJlZ3VsYXIsIGRhIGJlcmVpdHMgZ2VsYWRlblxuICAgICAgICAgIGNvbnN0IHdlaWdodFBhdGggPSBgJHtmb250LnBhdGh9LyR7d2VpZ2h0LmZpbGV9YFxuICAgICAgICAgIGNvbnN0IHdlaWdodFJlc3BvbnNlID0gYXdhaXQgZmV0Y2god2VpZ2h0UGF0aClcbiAgICAgICAgICBpZiAod2VpZ2h0UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodEJ1ZmZlciA9IGF3YWl0IHdlaWdodFJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodEJhc2U2NCA9IGFycmF5QnVmZmVyVG9CYXNlNjQod2VpZ2h0QnVmZmVyKVxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0U3R5bGUgPSBwZGZTZXR0aW5ncy53ZWlnaHRNYXBwaW5nW3dlaWdodC52YWx1ZV1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGRmLmFkZEZpbGVUb1ZGUyhgJHtmb250LmZhbWlseX0tJHt3ZWlnaHRTdHlsZX0udHRmYCwgd2VpZ2h0QmFzZTY0KVxuICAgICAgICAgICAgcGRmLmFkZEZvbnQoYCR7Zm9udC5mYW1pbHl9LSR7d2VpZ2h0U3R5bGV9LnR0ZmAsIGZvbnQuZmFtaWx5LCB3ZWlnaHRTdHlsZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NjaHJpZnRhcnQgZXJmb2xncmVpY2ggZ2VsYWRlbjonLCBmb250LmZhbWlseSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gTGFkZW4gZGVyIFNjaHJpZnRhcnQ6JywgZm9udC5mYW1pbHksIGVycm9yKVxuICAgIH1cbiAgfVxufVxuXG4vLyBTZXR6dCBkaWUgVGV4dHN0aWxlIGbDvHIgZGFzIFBERlxuZnVuY3Rpb24gYXBwbHlUZXh0U3R5bGUocGRmOiBqc1BERiwgYmxvY2s6IFRleHRCbG9jaykge1xuICB0cnkge1xuICAgIC8vIFZlcndlbmRlIGRpZSB0YXRzw6RjaGxpY2hlIFNjaHJpZnRhcnRcbiAgICBjb25zdCBmb250RmFtaWx5ID0gYmxvY2suZm9udEZhbWlseVxuICAgIGNvbnN0IGZvbnRXZWlnaHQgPSB0eXBlb2YgYmxvY2suZm9udFdlaWdodCA9PT0gJ3N0cmluZycgPyBwYXJzZUludChibG9jay5mb250V2VpZ2h0KSA6IGJsb2NrLmZvbnRXZWlnaHRcbiAgICBjb25zdCBmb250U3R5bGUgPSBwZGZTZXR0aW5ncy53ZWlnaHRNYXBwaW5nW2ZvbnRXZWlnaHRdIHx8ICdub3JtYWwnXG4gICAgXG4gICAgLy8gU2V0emUgZGllIFNjaHJpZnRhcnRcbiAgICBwZGYuc2V0Rm9udChmb250RmFtaWx5LCBmb250U3R5bGUpXG4gICAgXG4gICAgLy8gU2NocmlmdGdyw7bDn2VuYmVyZWNobnVuZyBtaXQgU2thbGllcnVuZ3NmYWt0b3JcbiAgICBjb25zdCBmb250U2l6ZSA9IE1hdGgucm91bmQoYmxvY2suZm9udFNpemUgKiBwZGZTZXR0aW5ncy5mb250U2NhbGVGYWN0b3IpXG4gICAgcGRmLnNldEZvbnRTaXplKGZvbnRTaXplKVxuICAgIFxuICAgIC8vIFNldHplIGRpZSBUZXh0ZmFyYmVcbiAgICBjb25zdCB0ZXh0Q29sb3IgPSBoZXhUb1JnYihibG9jay5jb2xvcilcbiAgICBwZGYuc2V0VGV4dENvbG9yKHRleHRDb2xvci5yLCB0ZXh0Q29sb3IuZywgdGV4dENvbG9yLmIpXG4gICAgXG4gICAgLy8gU2V0emUgZGVuIEJ1Y2hzdGFiZW5hYnN0YW5kLCBmYWxscyB2b3JoYW5kZW5cbiAgICBpZiAoYmxvY2subGV0dGVyU3BhY2luZykge1xuICAgICAgcGRmLnNldENoYXJTcGFjZShibG9jay5sZXR0ZXJTcGFjaW5nKVxuICAgIH1cbiAgICBcbiAgICAvLyBTZXR6ZSBkaWUgWmVpbGVuaMO2aGUsIGZhbGxzIHZvcmhhbmRlblxuICAgIGlmIChibG9jay5saW5lSGVpZ2h0KSB7XG4gICAgICBwZGYuc2V0TGluZUhlaWdodEZhY3RvcihibG9jay5saW5lSGVpZ2h0KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGZWhsZXIgYmVpbSBBbndlbmRlbiBkZXIgVGV4dHN0aWxlOicsIGVycm9yKVxuICAgIC8vIEZhbGxiYWNrIHp1IFN0YW5kYXJkLVNjaHJpZnRhcnRcbiAgICBwZGYuc2V0Rm9udCgnaGVsdmV0aWNhJywgJ25vcm1hbCcpXG4gIH1cbn1cblxuLy8gQmVyZWNobmV0IGRpZSBQb3NpdGlvbiBmw7xyIGRlbiBUZXh0XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0UG9zaXRpb24oYmxvY2s6IFRleHRCbG9jaywgcGFnZVdpZHRoOiBudW1iZXIsIHBhZ2VIZWlnaHQ6IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHg6IChibG9jay54IC8gMTAwKSAqIHBhZ2VXaWR0aCxcbiAgICB5OiAoYmxvY2sueSAvIDEwMCkgKiBwYWdlSGVpZ2h0XG4gIH1cbn1cblxuLy8gUmVuZGVydCBlaW5lbiBUZXh0YmxvY2sgaW0gUERGXG5mdW5jdGlvbiByZW5kZXJUZXh0QmxvY2socGRmOiBqc1BERiwgYmxvY2s6IFRleHRCbG9jaywgcGFnZVdpZHRoOiBudW1iZXIsIHBhZ2VIZWlnaHQ6IG51bWJlcikge1xuICAvLyBXZW5kZSBUZXh0c3RpbGUgYW5cbiAgYXBwbHlUZXh0U3R5bGUocGRmLCBibG9jaylcbiAgXG4gIC8vIEJlcmVjaG5lIFBvc2l0aW9uXG4gIGNvbnN0IHsgeCwgeSB9ID0gY2FsY3VsYXRlVGV4dFBvc2l0aW9uKGJsb2NrLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQpXG4gIFxuICAvLyBUZXh0IGVpbmbDvGdlblxuICBwZGYudGV4dChibG9jay50ZXh0LCB4LCB5LCB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICBtYXhXaWR0aDogcGFnZVdpZHRoIC0gKHBkZlNldHRpbmdzLm1pbk1hcmdpbiAqIDIpXG4gIH0pXG59XG5cbmludGVyZmFjZSBQZGZHZW5lcmF0b3JPcHRpb25zIHtcbiAgcGFnZVNpemU6IHN0cmluZ1xuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xuICBjb250ZW50OiBUZXh0QmxvY2tbXVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQREYob3B0aW9uczogUGRmR2VuZXJhdG9yT3B0aW9ucyk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAvLyBGaW5kZSBkaWUgYXVzZ2V3w6RobHRlIFBhcGllcmdyw7bDn2VcbiAgY29uc3QgYWxsU2l6ZXMgPSBbLi4ucGFwZXJTaXplcy5wb3N0ZXIucG9ydHJhaXQsIC4uLnBhcGVyU2l6ZXMucG9zdGVyLmxhbmRzY2FwZV1cbiAgY29uc3Qgc2VsZWN0ZWRTaXplID0gYWxsU2l6ZXMuZmluZChzaXplID0+IHNpemUuaWQgPT09IG9wdGlvbnMucGFnZVNpemUpXG4gIFxuICBpZiAoIXNlbGVjdGVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5nw7xsdGlnZSBQYXBpZXJncsO2w59lJylcbiAgfVxuXG4gIC8vIEV4dHJhaGllcmUgZGllIE1hw59lXG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2VsZWN0ZWRTaXplXG4gIGNvbnN0IG9yaWVudGF0aW9uID0gb3B0aW9ucy5wYWdlU2l6ZS5zdGFydHNXaXRoKCdsJykgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCdcbiAgY29uc3QgeyBibGVlZCB9ID0gcGRmU2V0dGluZ3NcblxuICAvLyBFcnN0ZWxsZSBQREZcbiAgY29uc3QgcGRmID0gbmV3IGpzUERGKHtcbiAgICBvcmllbnRhdGlvbixcbiAgICB1bml0OiAnbW0nLFxuICAgIGZvcm1hdDogW1xuICAgICAgd2lkdGggKyAoYmxlZWQgKiAyKSxcbiAgICAgIGhlaWdodCArIChibGVlZCAqIDIpXG4gICAgXVxuICB9KVxuXG4gIC8vIFJlZ2lzdHJpZXJlIGRpZSBTY2hyaWZ0YXJ0ZW5cbiAgYXdhaXQgcmVnaXN0ZXJGb250cyhwZGYpXG5cbiAgLy8gU2V0emUgSGludGVyZ3J1bmRmYXJiZVxuICBjb25zdCBiZ0NvbG9yID0gaGV4VG9SZ2Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpXG4gIHBkZi5zZXRGaWxsQ29sb3IoYmdDb2xvci5yLCBiZ0NvbG9yLmcsIGJnQ29sb3IuYilcbiAgcGRmLnJlY3QoXG4gICAgMCxcbiAgICAwLFxuICAgIHdpZHRoICsgKGJsZWVkICogMiksXG4gICAgaGVpZ2h0ICsgKGJsZWVkICogMiksXG4gICAgJ0YnXG4gIClcblxuICAvLyBGw7xnZSBhbGxlIFRleHRibMO2Y2tlIGVpblxuICBjb25zdCBwYWdlV2lkdGggPSB3aWR0aCArIChibGVlZCAqIDIpXG4gIGNvbnN0IHBhZ2VIZWlnaHQgPSBoZWlnaHQgKyAoYmxlZWQgKiAyKVxuICBcbiAgb3B0aW9ucy5jb250ZW50LmZvckVhY2goYmxvY2sgPT4ge1xuICAgIHJlbmRlclRleHRCbG9jayhwZGYsIGJsb2NrLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQpXG4gIH0pXG5cbiAgLy8gUERGIGFscyBVaW50OEFycmF5IHp1csO8Y2tnZWJlblxuICBjb25zdCBhcnJheUJ1ZmZlciA9IHBkZi5vdXRwdXQoJ2FycmF5YnVmZmVyJylcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKVxufVxuIl0sIm5hbWVzIjpbImpzUERGIiwicGFwZXJTaXplcyIsInBkZlNldHRpbmdzIiwiZm9udHMiLCJoZXhUb1JnYiIsImhleCIsInJlc3VsdCIsImV4ZWMiLCJyIiwicGFyc2VJbnQiLCJnIiwiYiIsImFycmF5QnVmZmVyVG9CYXNlNjQiLCJidWZmZXIiLCJiaW5hcnkiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwiYnl0ZUxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJyZWdpc3RlckZvbnRzIiwicGRmIiwiZm9udCIsInJlZ3VsYXJXZWlnaHQiLCJ3ZWlnaHRzIiwiZmluZCIsInciLCJ2YWx1ZSIsImZvbnRQYXRoIiwicGF0aCIsImZpbGUiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJmb250QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJmb250QmFzZTY0IiwiYWRkRmlsZVRvVkZTIiwiZmFtaWx5IiwiYWRkRm9udCIsIndlaWdodCIsIndlaWdodFBhdGgiLCJ3ZWlnaHRSZXNwb25zZSIsIndlaWdodEJ1ZmZlciIsIndlaWdodEJhc2U2NCIsIndlaWdodFN0eWxlIiwid2VpZ2h0TWFwcGluZyIsImVycm9yIiwiYXBwbHlUZXh0U3R5bGUiLCJibG9jayIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwic2V0Rm9udCIsImZvbnRTaXplIiwiTWF0aCIsInJvdW5kIiwiZm9udFNjYWxlRmFjdG9yIiwic2V0Rm9udFNpemUiLCJ0ZXh0Q29sb3IiLCJjb2xvciIsInNldFRleHRDb2xvciIsImxldHRlclNwYWNpbmciLCJzZXRDaGFyU3BhY2UiLCJsaW5lSGVpZ2h0Iiwic2V0TGluZUhlaWdodEZhY3RvciIsImNhbGN1bGF0ZVRleHRQb3NpdGlvbiIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJ4IiwieSIsInJlbmRlclRleHRCbG9jayIsInRleHQiLCJhbGlnbiIsImJhc2VsaW5lIiwibWF4V2lkdGgiLCJtaW5NYXJnaW4iLCJnZW5lcmF0ZVBERiIsIm9wdGlvbnMiLCJhbGxTaXplcyIsInBvc3RlciIsInBvcnRyYWl0IiwibGFuZHNjYXBlIiwic2VsZWN0ZWRTaXplIiwic2l6ZSIsImlkIiwicGFnZVNpemUiLCJ3aWR0aCIsImhlaWdodCIsIm9yaWVudGF0aW9uIiwic3RhcnRzV2l0aCIsImJsZWVkIiwidW5pdCIsImZvcm1hdCIsImJnQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZXRGaWxsQ29sb3IiLCJyZWN0IiwiY29udGVudCIsImZvckVhY2giLCJvdXRwdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdf-generator.ts\n"));

/***/ })

});