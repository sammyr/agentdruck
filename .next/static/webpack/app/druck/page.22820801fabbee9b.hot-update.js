"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/druck/page",{

/***/ "(app-pages-browser)/./src/lib/pdf-generator.ts":
/*!**********************************!*\
  !*** ./src/lib/pdf-generator.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generatePDF: function() { return /* binding */ generatePDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var _data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/data/paper-sizes.json */ \"(app-pages-browser)/./src/data/paper-sizes.json\");\n/* harmony import */ var _config_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/config/settings */ \"(app-pages-browser)/./src/config/settings.ts\");\n/* harmony import */ var _data_fonts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/data/fonts */ \"(app-pages-browser)/./src/data/fonts.ts\");\n// !!! WICHTIG: Diese Datei ist essentiell für die PDF-Generierung und darf nicht gelöscht werden !!!\n// !!! Sie enthält die Logik für die Erstellung der PDF-Dokumente mit allen Einstellungen !!!\n\n\n\n\n// Konvertiert Hex-Farbe in RGB\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : {\n        r: 255,\n        g: 255,\n        b: 255\n    };\n}\n// Konvertiere ArrayBuffer zu Base64\nfunction arrayBufferToBase64(buffer) {\n    let binary = \"\";\n    const bytes = new Uint8Array(buffer);\n    for(let i = 0; i < bytes.byteLength; i++){\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n// Registriere die Schriftarten für jsPDF\nasync function registerFonts(pdf) {\n    for (const font of _data_fonts__WEBPACK_IMPORTED_MODULE_3__.fonts){\n        for (const weight of font.weights){\n            try {\n                // Erstelle den vollständigen Pfad zur Schriftart\n                const fontPath = \"\".concat(font.path, \"/\").concat(weight.file);\n                console.log(\"Lade Schriftart:\", fontPath);\n                const response = await fetch(fontPath);\n                if (!response.ok) {\n                    throw new Error(\"HTTP error! status: \".concat(response.status));\n                }\n                const fontBuffer = await response.arrayBuffer();\n                const fontBase64 = arrayBufferToBase64(fontBuffer);\n                // Registriere die Schriftart mit jsPDF mit dem korrekten Gewicht\n                const fontStyle = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.weightMapping[weight.value];\n                const fontKey = \"\".concat(font.family, \"-\").concat(weight.value);\n                pdf.addFileToVFS(fontKey, fontBase64);\n                pdf.addFont(fontKey, font.family, fontStyle);\n                console.log(\"Schriftart erfolgreich geladen:\", font.family, weight.name, fontStyle);\n            } catch (error) {\n                console.error(\"Fehler beim Laden der Schriftart:\", font.family, weight.name, error);\n            }\n        }\n    }\n}\n// Setzt die Textstile für das PDF\nfunction applyTextStyle(pdf, block) {\n    // Verwende die tatsächliche Schriftart mit dem korrekten Gewicht\n    const fontFamily = block.fontFamily;\n    const fontWeight = typeof block.fontWeight === \"string\" ? parseInt(block.fontWeight) : block.fontWeight;\n    const fontStyle = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.weightMapping[fontWeight] || \"normal\";\n    // Setze die Schriftart mit dem spezifischen Gewicht\n    const fontKey = \"\".concat(fontFamily, \"-\").concat(fontWeight);\n    pdf.setFont(fontKey, fontStyle);\n    // Schriftgrößenberechnung mit Skalierungsfaktor aus den Einstellungen\n    const fontSize = Math.round(block.fontSize * _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.fontScaleFactor);\n    pdf.setFontSize(fontSize);\n    // Setze die Textfarbe\n    const textColor = hexToRgb(block.color);\n    pdf.setTextColor(textColor.r, textColor.g, textColor.b);\n    // Setze den Buchstabenabstand, falls vorhanden\n    if (block.letterSpacing) {\n        pdf.setCharSpace(block.letterSpacing);\n    }\n    // Setze die Zeilenhöhe, falls vorhanden\n    if (block.lineHeight) {\n        pdf.setLineHeightFactor(block.lineHeight);\n    }\n}\n// Berechnet die Position für den Text\nfunction calculateTextPosition(block, pageWidth, pageHeight) {\n    return {\n        x: block.x / 100 * pageWidth,\n        y: block.y / 100 * pageHeight\n    };\n}\n// Rendert einen Textblock im PDF\nfunction renderTextBlock(pdf, block, pageWidth, pageHeight) {\n    // Wende Textstile an\n    applyTextStyle(pdf, block);\n    // Berechne Position\n    const { x, y } = calculateTextPosition(block, pageWidth, pageHeight);\n    // Text einfügen\n    pdf.text(block.text, x, y, {\n        align: \"center\",\n        baseline: \"middle\",\n        maxWidth: pageWidth - _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings.minMargin * 2\n    });\n}\nasync function generatePDF(options) {\n    // Finde die ausgewählte Papiergröße\n    const allSizes = [\n        ..._data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__.poster.portrait,\n        ..._data_paper_sizes_json__WEBPACK_IMPORTED_MODULE_1__.poster.landscape\n    ];\n    const selectedSize = allSizes.find((size)=>size.id === options.pageSize);\n    if (!selectedSize) {\n        throw new Error(\"Ung\\xfcltige Papiergr\\xf6\\xdfe\");\n    }\n    // Extrahiere die Maße\n    const { width, height } = selectedSize;\n    const orientation = options.pageSize.startsWith(\"l\") ? \"landscape\" : \"portrait\";\n    const { bleed } = _config_settings__WEBPACK_IMPORTED_MODULE_2__.pdfSettings;\n    // Erstelle PDF\n    const pdf = new jspdf__WEBPACK_IMPORTED_MODULE_0__.jsPDF({\n        orientation,\n        unit: \"mm\",\n        format: [\n            width + bleed * 2,\n            height + bleed * 2\n        ]\n    });\n    // Registriere die Schriftarten\n    await registerFonts(pdf);\n    // Setze Hintergrundfarbe\n    const bgColor = hexToRgb(options.backgroundColor);\n    pdf.setFillColor(bgColor.r, bgColor.g, bgColor.b);\n    pdf.rect(0, 0, width + bleed * 2, height + bleed * 2, \"F\");\n    // Füge alle Textblöcke ein\n    const pageWidth = width + bleed * 2;\n    const pageHeight = height + bleed * 2;\n    options.content.forEach((block)=>{\n        renderTextBlock(pdf, block, pageWidth, pageHeight);\n    });\n    // PDF als Uint8Array zurückgeben\n    const arrayBuffer = pdf.output(\"arraybuffer\");\n    return new Uint8Array(arrayBuffer);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcGRmLWdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHFHQUFxRztBQUNyRyw2RkFBNkY7QUFFaEU7QUFDbUI7QUFFRDtBQUNYO0FBRXBDLCtCQUErQjtBQUMvQixTQUFTSSxTQUFTQyxHQUFXO0lBQzNCLE1BQU1DLFNBQVMsNENBQTRDQyxJQUFJLENBQUNGO0lBQ2hFLE9BQU9DLFNBQVM7UUFDZEUsR0FBR0MsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkksR0FBR0QsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkssR0FBR0YsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtJQUN6QixJQUFJO1FBQUVFLEdBQUc7UUFBS0UsR0FBRztRQUFLQyxHQUFHO0lBQUk7QUFDL0I7QUFFQSxvQ0FBb0M7QUFDcEMsU0FBU0Msb0JBQW9CQyxNQUFtQjtJQUM5QyxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsUUFBUSxJQUFJQyxXQUFXSDtJQUM3QixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUYsTUFBTUcsVUFBVSxFQUFFRCxJQUFLO1FBQ3pDSCxVQUFVSyxPQUFPQyxZQUFZLENBQUNMLEtBQUssQ0FBQ0UsRUFBRTtJQUN4QztJQUNBLE9BQU9JLEtBQUtQO0FBQ2Q7QUFFQSx5Q0FBeUM7QUFDekMsZUFBZVEsY0FBY0MsR0FBVTtJQUNyQyxLQUFLLE1BQU1DLFFBQVFyQiw4Q0FBS0EsQ0FBRTtRQUN4QixLQUFLLE1BQU1zQixVQUFVRCxLQUFLRSxPQUFPLENBQUU7WUFDakMsSUFBSTtnQkFDRixpREFBaUQ7Z0JBQ2pELE1BQU1DLFdBQVcsR0FBZ0JGLE9BQWJELEtBQUtJLElBQUksRUFBQyxLQUFlLE9BQVpILE9BQU9JLElBQUk7Z0JBQzVDQyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CSjtnQkFFaEMsTUFBTUssV0FBVyxNQUFNQyxNQUFNTjtnQkFDN0IsSUFBSSxDQUFDSyxTQUFTRSxF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LElBQUlyRixXQUFXc0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9wZGYtZ2VuZXJhdG9yLnRzPzg2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gISEhIFdJQ0hUSUc6IERpZXNlIERhdGVpIGlzdCBlc3NlbnRpZWxsIGbDvHIgZGllIFBERi1HZW5lcmllcnVuZyB1bmQgZGFyZiBuaWNodCBnZWzDtnNjaHQgd2VyZGVuICEhIVxuLy8gISEhIFNpZSBlbnRow6RsdCBkaWUgTG9naWsgZsO8ciBkaWUgRXJzdGVsbHVuZyBkZXIgUERGLURva3VtZW50ZSBtaXQgYWxsZW4gRWluc3RlbGx1bmdlbiAhISFcblxuaW1wb3J0IHsganNQREYgfSBmcm9tICdqc3BkZidcbmltcG9ydCBwYXBlclNpemVzIGZyb20gJ0AvZGF0YS9wYXBlci1zaXplcy5qc29uJ1xuaW1wb3J0IHsgVGV4dEJsb2NrIH0gZnJvbSAnQC90eXBlcy90ZXh0J1xuaW1wb3J0IHsgcGRmU2V0dGluZ3MgfSBmcm9tICdAL2NvbmZpZy9zZXR0aW5ncydcbmltcG9ydCB7IGZvbnRzIH0gZnJvbSAnQC9kYXRhL2ZvbnRzJ1xuXG4vLyBLb252ZXJ0aWVydCBIZXgtRmFyYmUgaW4gUkdCXG5mdW5jdGlvbiBoZXhUb1JnYihoZXg6IHN0cmluZykge1xuICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KVxuICByZXR1cm4gcmVzdWx0ID8ge1xuICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxuICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gIH0gOiB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUgfVxufVxuXG4vLyBLb252ZXJ0aWVyZSBBcnJheUJ1ZmZlciB6dSBCYXNlNjRcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyOiBBcnJheUJ1ZmZlcik6IHN0cmluZyB7XG4gIGxldCBiaW5hcnkgPSAnJztcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuXG4vLyBSZWdpc3RyaWVyZSBkaWUgU2NocmlmdGFydGVuIGbDvHIganNQREZcbmFzeW5jIGZ1bmN0aW9uIHJlZ2lzdGVyRm9udHMocGRmOiBqc1BERikge1xuICBmb3IgKGNvbnN0IGZvbnQgb2YgZm9udHMpIHtcbiAgICBmb3IgKGNvbnN0IHdlaWdodCBvZiBmb250LndlaWdodHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEVyc3RlbGxlIGRlbiB2b2xsc3TDpG5kaWdlbiBQZmFkIHp1ciBTY2hyaWZ0YXJ0XG4gICAgICAgIGNvbnN0IGZvbnRQYXRoID0gYCR7Zm9udC5wYXRofS8ke3dlaWdodC5maWxlfWBcbiAgICAgICAgY29uc29sZS5sb2coJ0xhZGUgU2NocmlmdGFydDonLCBmb250UGF0aClcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZm9udFBhdGgpXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb250QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICBjb25zdCBmb250QmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChmb250QnVmZmVyKVxuICAgICAgICBcbiAgICAgICAgLy8gUmVnaXN0cmllcmUgZGllIFNjaHJpZnRhcnQgbWl0IGpzUERGIG1pdCBkZW0ga29ycmVrdGVuIEdld2ljaHRcbiAgICAgICAgY29uc3QgZm9udFN0eWxlID0gcGRmU2V0dGluZ3Mud2VpZ2h0TWFwcGluZ1t3ZWlnaHQudmFsdWVdXG4gICAgICAgIGNvbnN0IGZvbnRLZXkgPSBgJHtmb250LmZhbWlseX0tJHt3ZWlnaHQudmFsdWV9YFxuICAgICAgICBcbiAgICAgICAgcGRmLmFkZEZpbGVUb1ZGUyhmb250S2V5LCBmb250QmFzZTY0KVxuICAgICAgICBwZGYuYWRkRm9udChmb250S2V5LCBmb250LmZhbWlseSwgZm9udFN0eWxlKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1NjaHJpZnRhcnQgZXJmb2xncmVpY2ggZ2VsYWRlbjonLCBmb250LmZhbWlseSwgd2VpZ2h0Lm5hbWUsIGZvbnRTdHlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZlaGxlciBiZWltIExhZGVuIGRlciBTY2hyaWZ0YXJ0OicsIGZvbnQuZmFtaWx5LCB3ZWlnaHQubmFtZSwgZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFNldHp0IGRpZSBUZXh0c3RpbGUgZsO8ciBkYXMgUERGXG5mdW5jdGlvbiBhcHBseVRleHRTdHlsZShwZGY6IGpzUERGLCBibG9jazogVGV4dEJsb2NrKSB7XG4gIC8vIFZlcndlbmRlIGRpZSB0YXRzw6RjaGxpY2hlIFNjaHJpZnRhcnQgbWl0IGRlbSBrb3JyZWt0ZW4gR2V3aWNodFxuICBjb25zdCBmb250RmFtaWx5ID0gYmxvY2suZm9udEZhbWlseVxuICBjb25zdCBmb250V2VpZ2h0ID0gdHlwZW9mIGJsb2NrLmZvbnRXZWlnaHQgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoYmxvY2suZm9udFdlaWdodCkgOiBibG9jay5mb250V2VpZ2h0XG4gIGNvbnN0IGZvbnRTdHlsZSA9IHBkZlNldHRpbmdzLndlaWdodE1hcHBpbmdbZm9udFdlaWdodF0gfHwgJ25vcm1hbCdcbiAgXG4gIC8vIFNldHplIGRpZSBTY2hyaWZ0YXJ0IG1pdCBkZW0gc3BlemlmaXNjaGVuIEdld2ljaHRcbiAgY29uc3QgZm9udEtleSA9IGAke2ZvbnRGYW1pbHl9LSR7Zm9udFdlaWdodH1gXG4gIHBkZi5zZXRGb250KGZvbnRLZXksIGZvbnRTdHlsZSlcbiAgXG4gIC8vIFNjaHJpZnRncsO2w59lbmJlcmVjaG51bmcgbWl0IFNrYWxpZXJ1bmdzZmFrdG9yIGF1cyBkZW4gRWluc3RlbGx1bmdlblxuICBjb25zdCBmb250U2l6ZSA9IE1hdGgucm91bmQoYmxvY2suZm9udFNpemUgKiBwZGZTZXR0aW5ncy5mb250U2NhbGVGYWN0b3IpXG4gIHBkZi5zZXRGb250U2l6ZShmb250U2l6ZSlcbiAgXG4gIC8vIFNldHplIGRpZSBUZXh0ZmFyYmVcbiAgY29uc3QgdGV4dENvbG9yID0gaGV4VG9SZ2IoYmxvY2suY29sb3IpXG4gIHBkZi5zZXRUZXh0Q29sb3IodGV4dENvbG9yLnIsIHRleHRDb2xvci5nLCB0ZXh0Q29sb3IuYilcbiAgXG4gIC8vIFNldHplIGRlbiBCdWNoc3RhYmVuYWJzdGFuZCwgZmFsbHMgdm9yaGFuZGVuXG4gIGlmIChibG9jay5sZXR0ZXJTcGFjaW5nKSB7XG4gICAgcGRmLnNldENoYXJTcGFjZShibG9jay5sZXR0ZXJTcGFjaW5nKVxuICB9XG4gIFxuICAvLyBTZXR6ZSBkaWUgWmVpbGVuaMO2aGUsIGZhbGxzIHZvcmhhbmRlblxuICBpZiAoYmxvY2subGluZUhlaWdodCkge1xuICAgIHBkZi5zZXRMaW5lSGVpZ2h0RmFjdG9yKGJsb2NrLmxpbmVIZWlnaHQpXG4gIH1cbn1cblxuLy8gQmVyZWNobmV0IGRpZSBQb3NpdGlvbiBmw7xyIGRlbiBUZXh0XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0UG9zaXRpb24oYmxvY2s6IFRleHRCbG9jaywgcGFnZVdpZHRoOiBudW1iZXIsIHBhZ2VIZWlnaHQ6IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHg6IChibG9jay54IC8gMTAwKSAqIHBhZ2VXaWR0aCxcbiAgICB5OiAoYmxvY2sueSAvIDEwMCkgKiBwYWdlSGVpZ2h0XG4gIH1cbn1cblxuLy8gUmVuZGVydCBlaW5lbiBUZXh0YmxvY2sgaW0gUERGXG5mdW5jdGlvbiByZW5kZXJUZXh0QmxvY2socGRmOiBqc1BERiwgYmxvY2s6IFRleHRCbG9jaywgcGFnZVdpZHRoOiBudW1iZXIsIHBhZ2VIZWlnaHQ6IG51bWJlcikge1xuICAvLyBXZW5kZSBUZXh0c3RpbGUgYW5cbiAgYXBwbHlUZXh0U3R5bGUocGRmLCBibG9jaylcbiAgXG4gIC8vIEJlcmVjaG5lIFBvc2l0aW9uXG4gIGNvbnN0IHsgeCwgeSB9ID0gY2FsY3VsYXRlVGV4dFBvc2l0aW9uKGJsb2NrLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQpXG4gIFxuICAvLyBUZXh0IGVpbmbDvGdlblxuICBwZGYudGV4dChibG9jay50ZXh0LCB4LCB5LCB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICBtYXhXaWR0aDogcGFnZVdpZHRoIC0gKHBkZlNldHRpbmdzLm1pbk1hcmdpbiAqIDIpXG4gIH0pXG59XG5cbmludGVyZmFjZSBQZGZHZW5lcmF0b3JPcHRpb25zIHtcbiAgcGFnZVNpemU6IHN0cmluZ1xuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xuICBjb250ZW50OiBUZXh0QmxvY2tbXVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQREYob3B0aW9uczogUGRmR2VuZXJhdG9yT3B0aW9ucyk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAvLyBGaW5kZSBkaWUgYXVzZ2V3w6RobHRlIFBhcGllcmdyw7bDn2VcbiAgY29uc3QgYWxsU2l6ZXMgPSBbLi4ucGFwZXJTaXplcy5wb3N0ZXIucG9ydHJhaXQsIC4uLnBhcGVyU2l6ZXMucG9zdGVyLmxhbmRzY2FwZV1cbiAgY29uc3Qgc2VsZWN0ZWRTaXplID0gYWxsU2l6ZXMuZmluZChzaXplID0+IHNpemUuaWQgPT09IG9wdGlvbnMucGFnZVNpemUpXG4gIFxuICBpZiAoIXNlbGVjdGVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5nw7xsdGlnZSBQYXBpZXJncsO2w59lJylcbiAgfVxuXG4gIC8vIEV4dHJhaGllcmUgZGllIE1hw59lXG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2VsZWN0ZWRTaXplXG4gIGNvbnN0IG9yaWVudGF0aW9uID0gb3B0aW9ucy5wYWdlU2l6ZS5zdGFydHNXaXRoKCdsJykgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCdcbiAgY29uc3QgeyBibGVlZCB9ID0gcGRmU2V0dGluZ3NcblxuICAvLyBFcnN0ZWxsZSBQREZcbiAgY29uc3QgcGRmID0gbmV3IGpzUERGKHtcbiAgICBvcmllbnRhdGlvbixcbiAgICB1bml0OiAnbW0nLFxuICAgIGZvcm1hdDogW1xuICAgICAgd2lkdGggKyAoYmxlZWQgKiAyKSxcbiAgICAgIGhlaWdodCArIChibGVlZCAqIDIpXG4gICAgXVxuICB9KVxuXG4gIC8vIFJlZ2lzdHJpZXJlIGRpZSBTY2hyaWZ0YXJ0ZW5cbiAgYXdhaXQgcmVnaXN0ZXJGb250cyhwZGYpXG5cbiAgLy8gU2V0emUgSGludGVyZ3J1bmRmYXJiZVxuICBjb25zdCBiZ0NvbG9yID0gaGV4VG9SZ2Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpXG4gIHBkZi5zZXRGaWxsQ29sb3IoYmdDb2xvci5yLCBiZ0NvbG9yLmcsIGJnQ29sb3IuYilcbiAgcGRmLnJlY3QoXG4gICAgMCxcbiAgICAwLFxuICAgIHdpZHRoICsgKGJsZWVkICogMiksXG4gICAgaGVpZ2h0ICsgKGJsZWVkICogMiksXG4gICAgJ0YnXG4gIClcblxuICAvLyBGw7xnZSBhbGxlIFRleHRibMO2Y2tlIGVpblxuICBjb25zdCBwYWdlV2lkdGggPSB3aWR0aCArIChibGVlZCAqIDIpXG4gIGNvbnN0IHBhZ2VIZWlnaHQgPSBoZWlnaHQgKyAoYmxlZWQgKiAyKVxuICBcbiAgb3B0aW9ucy5jb250ZW50LmZvckVhY2goYmxvY2sgPT4ge1xuICAgIHJlbmRlclRleHRCbG9jayhwZGYsIGJsb2NrLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQpXG4gIH0pXG5cbiAgLy8gUERGIGFscyBVaW50OEFycmF5IHp1csO8Y2tnZWJlblxuICBjb25zdCBhcnJheUJ1ZmZlciA9IHBkZi5vdXRwdXQoJ2FycmF5YnVmZmVyJylcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKVxufVxuIl0sIm5hbWVzIjpbImpzUERGIiwicGFwZXJTaXplcyIsInBkZlNldHRpbmdzIiwiZm9udHMiLCJoZXhUb1JnYiIsImhleCIsInJlc3VsdCIsImV4ZWMiLCJyIiwicGFyc2VJbnQiLCJnIiwiYiIsImFycmF5QnVmZmVyVG9CYXNlNjQiLCJidWZmZXIiLCJiaW5hcnkiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwiYnl0ZUxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ0b2EiLCJyZWdpc3RlckZvbnRzIiwicGRmIiwiZm9udCIsIndlaWdodCIsIndlaWdodHMiLCJmb250UGF0aCIsInBhdGgiLCJmaWxlIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwiZm9udEJ1ZmZlciIsImFycmF5QnVmZmVyIiwiZm9udEJhc2U2NCIsImZvbnRTdHlsZSIsIndlaWdodE1hcHBpbmciLCJ2YWx1ZSIsImZvbnRLZXkiLCJmYW1pbHkiLCJhZGRGaWxlVG9WRlMiLCJhZGRGb250IiwibmFtZSIsImVycm9yIiwiYXBwbHlUZXh0U3R5bGUiLCJibG9jayIsImZvbnRGYW1pbHkiLCJmb250V2VpZ2h0Iiwic2V0Rm9udCIsImZvbnRTaXplIiwiTWF0aCIsInJvdW5kIiwiZm9udFNjYWxlRmFjdG9yIiwic2V0Rm9udFNpemUiLCJ0ZXh0Q29sb3IiLCJjb2xvciIsInNldFRleHRDb2xvciIsImxldHRlclNwYWNpbmciLCJzZXRDaGFyU3BhY2UiLCJsaW5lSGVpZ2h0Iiwic2V0TGluZUhlaWdodEZhY3RvciIsImNhbGN1bGF0ZVRleHRQb3NpdGlvbiIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJ4IiwieSIsInJlbmRlclRleHRCbG9jayIsInRleHQiLCJhbGlnbiIsImJhc2VsaW5lIiwibWF4V2lkdGgiLCJtaW5NYXJnaW4iLCJnZW5lcmF0ZVBERiIsIm9wdGlvbnMiLCJhbGxTaXplcyIsInBvc3RlciIsInBvcnRyYWl0IiwibGFuZHNjYXBlIiwic2VsZWN0ZWRTaXplIiwiZmluZCIsInNpemUiLCJpZCIsInBhZ2VTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJvcmllbnRhdGlvbiIsInN0YXJ0c1dpdGgiLCJibGVlZCIsInVuaXQiLCJmb3JtYXQiLCJiZ0NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwic2V0RmlsbENvbG9yIiwicmVjdCIsImNvbnRlbnQiLCJmb3JFYWNoIiwib3V0cHV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdf-generator.ts\n"));

/***/ })

});