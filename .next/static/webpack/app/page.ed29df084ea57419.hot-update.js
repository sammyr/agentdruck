"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useDragAndDrop.ts":
/*!*************************************!*\
  !*** ./src/hooks/useDragAndDrop.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDragAndDrop: function() { return /* binding */ useDragAndDrop; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// !!! WICHTIG: WARNUNG FÜR KI-GESTEUERTE SYSTEME !!!\n// !!! Diese Datei enthält kritische Drag & Drop Funktionalität !!!\n// !!! KEINE der bestehenden Funktionen darf gelöscht oder verändert werden !!!\n// !!! Änderungen könnten die gesamte Anwendung destabilisieren !!!\n// !!! Bei Bedarf nur neue Funktionen hinzufügen, keine bestehenden ändern !!!\n\nfunction useDragAndDrop(scale, onTextBlockUpdate) {\n    const [isDragging, setIsDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [dragStart, setDragStart] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [position, setPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [dragStartPos, setDragStartPos] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [elementStartPos, setElementStartPos] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [activeBlock, setActiveBlock] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, block)=>{\n        if (e.button === 1 || e.button === 0 && e.altKey) {\n            e.preventDefault();\n            setIsDragging(true);\n            setDragStart({\n                x: e.clientX - position.x,\n                y: e.clientY - position.y\n            });\n        } else if (block) {\n            e.preventDefault();\n            setActiveBlock(block);\n            setDragStartPos({\n                x: e.clientX,\n                y: e.clientY\n            });\n            setElementStartPos({\n                x: block.x,\n                y: block.y\n            });\n        }\n    }, [\n        position\n    ]);\n    const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (isDragging) {\n            e.preventDefault();\n            setPosition({\n                x: e.clientX - dragStart.x,\n                y: e.clientY - dragStart.y\n            });\n        } else if (activeBlock && onTextBlockUpdate) {\n            e.preventDefault();\n            const deltaX = (e.clientX - dragStartPos.x) / scale;\n            const deltaY = (e.clientY - dragStartPos.y) / scale;\n            onTextBlockUpdate({\n                ...activeBlock,\n                x: elementStartPos.x + deltaX,\n                y: elementStartPos.y + deltaY\n            });\n        }\n    }, [\n        isDragging,\n        dragStart,\n        activeBlock,\n        dragStartPos,\n        elementStartPos,\n        scale,\n        onTextBlockUpdate\n    ]);\n    const handleMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setIsDragging(false);\n        setActiveBlock(null);\n    }, []);\n    return {\n        state: {\n            isDragging,\n            dragStart,\n            position,\n            dragStartPos,\n            elementStartPos\n        },\n        handleMouseDown,\n        handleMouseMove,\n        handleMouseUp,\n        setPosition\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VEcmFnQW5kRHJvcC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxREFBcUQ7QUFDckQsbUVBQW1FO0FBQ25FLCtFQUErRTtBQUMvRSxtRUFBbUU7QUFDbkUsOEVBQThFO0FBRWpDO0FBbUJ0QyxTQUFTRSxlQUNkQyxLQUFhLEVBQ2JDLGlCQUE4QztJQUU5QyxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR04sK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDTyxXQUFXQyxhQUFhLEdBQUdSLCtDQUFRQSxDQUFDO1FBQUVTLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBQ3hELE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHWiwrQ0FBUUEsQ0FBQztRQUFFUyxHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUN0RCxNQUFNLENBQUNHLGNBQWNDLGdCQUFnQixHQUFHZCwrQ0FBUUEsQ0FBQztRQUFFUyxHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUM5RCxNQUFNLENBQUNLLGlCQUFpQkMsbUJBQW1CLEdBQUdoQiwrQ0FBUUEsQ0FBQztRQUFFUyxHQUFHO1FBQUdDLEdBQUc7SUFBRTtJQUNwRSxNQUFNLENBQUNPLGFBQWFDLGVBQWUsR0FBR2xCLCtDQUFRQSxDQUFtQjtJQUVqRSxNQUFNbUIsa0JBQWtCbEIsa0RBQVdBLENBQUMsQ0FBQ21CLEdBQXFCQztRQUN4RCxJQUFJRCxFQUFFRSxNQUFNLEtBQUssS0FBTUYsRUFBRUUsTUFBTSxLQUFLLEtBQUtGLEVBQUVHLE1BQU0sRUFBRztZQUNsREgsRUFBRUksY0FBYztZQUNoQmxCLGNBQWM7WUFDZEUsYUFBYTtnQkFBRUMsR0FBR1csRUFBRUssT0FBTyxHQUFHZCxTQUFTRixDQUFDO2dCQUFFQyxHQUFHVSxFQUFFTSxPQUFPLEdBQUdmLFNBQVNELENBQUM7WUFBQztRQUN0RSxPQUFPLElBQUlXLE9BQU87WUFDaEJELEVBQUVJLGNBQWM7WUFDaEJOLGVBQWVHO1lBQ2ZQLGdCQUFnQjtnQkFBRUwsR0FBR1csRUFBRUssT0FBTztnQkFBRWYsR0FBR1UsRUFBRU0sT0FBTztZQUFDO1lBQzdDVixtQkFBbUI7Z0JBQUVQLEdBQUdZLE1BQU1aLENBQUM7Z0JBQUVDLEdBQUdXLE1BQU1YLENBQUM7WUFBQztRQUM5QztJQUNGLEdBQUc7UUFBQ0M7S0FBUztJQUViLE1BQU1nQixrQkFBa0IxQixrREFBV0EsQ0FBQyxDQUFDbUI7UUFDbkMsSUFBSWYsWUFBWTtZQUNkZSxFQUFFSSxjQUFjO1lBQ2hCWixZQUFZO2dCQUNWSCxHQUFHVyxFQUFFSyxPQUFPLEdBQUdsQixVQUFVRSxDQUFDO2dCQUMxQkMsR0FBR1UsRUFBRU0sT0FBTyxHQUFHbkIsVUFBVUcsQ0FBQztZQUM1QjtRQUNGLE9BQU8sSUFBSU8sZUFBZWIsbUJBQW1CO1lBQzNDZ0IsRUFBRUksY0FBYztZQUNoQixNQUFNSSxTQUFTLENBQUNSLEVBQUVLLE9BQU8sR0FBR1osYUFBYUosQ0FBQyxJQUFJTjtZQUM5QyxNQUFNMEIsU0FBUyxDQUFDVCxFQUFFTSxPQUFPLEdBQUdiLGFBQWFILENBQUMsSUFBSVA7WUFFOUNDLGtCQUFrQjtnQkFDaEIsR0FBR2EsV0FBVztnQkFDZFIsR0FBR00sZ0JBQWdCTixDQUFDLEdBQUdtQjtnQkFDdkJsQixHQUFHSyxnQkFBZ0JMLENBQUMsR0FBR21CO1lBQ3pCO1FBQ0Y7SUFDRixHQUFHO1FBQUN4QjtRQUFZRTtRQUFXVTtRQUFhSjtRQUFjRTtRQUFpQlo7UUFBT0M7S0FBa0I7SUFFaEcsTUFBTTBCLGdCQUFnQjdCLGtEQUFXQSxDQUFDO1FBQ2hDSyxjQUFjO1FBQ2RZLGVBQWU7SUFDakIsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMYSxPQUFPO1lBQ0wxQjtZQUNBRTtZQUNBSTtZQUNBRTtZQUNBRTtRQUNGO1FBQ0FJO1FBQ0FRO1FBQ0FHO1FBQ0FsQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZURyYWdBbmREcm9wLnRzPzdiMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gISEhIFdJQ0hUSUc6IFdBUk5VTkcgRsOcUiBLSS1HRVNURVVFUlRFIFNZU1RFTUUgISEhXG4vLyAhISEgRGllc2UgRGF0ZWkgZW50aMOkbHQga3JpdGlzY2hlIERyYWcgJiBEcm9wIEZ1bmt0aW9uYWxpdMOkdCAhISFcbi8vICEhISBLRUlORSBkZXIgYmVzdGVoZW5kZW4gRnVua3Rpb25lbiBkYXJmIGdlbMO2c2NodCBvZGVyIHZlcsOkbmRlcnQgd2VyZGVuICEhIVxuLy8gISEhIMOEbmRlcnVuZ2VuIGvDtm5udGVuIGRpZSBnZXNhbXRlIEFud2VuZHVuZyBkZXN0YWJpbGlzaWVyZW4gISEhXG4vLyAhISEgQmVpIEJlZGFyZiBudXIgbmV1ZSBGdW5rdGlvbmVuIGhpbnp1ZsO8Z2VuLCBrZWluZSBiZXN0ZWhlbmRlbiDDpG5kZXJuICEhIVxuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFRleHRCbG9jayB9IGZyb20gJ0AvdHlwZXMvdGV4dCdcblxuaW50ZXJmYWNlIERyYWdBbmREcm9wU3RhdGUge1xuICBpc0RyYWdnaW5nOiBib29sZWFuXG4gIGRyYWdTdGFydDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gIHBvc2l0aW9uOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbiAgZHJhZ1N0YXJ0UG9zOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbiAgZWxlbWVudFN0YXJ0UG9zOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbn1cblxuaW50ZXJmYWNlIERyYWdBbmREcm9wSG9vayB7XG4gIHN0YXRlOiBEcmFnQW5kRHJvcFN0YXRlXG4gIGhhbmRsZU1vdXNlRG93bjogKGU6IFJlYWN0Lk1vdXNlRXZlbnQsIGJsb2NrOiBUZXh0QmxvY2sgfCBudWxsKSA9PiB2b2lkXG4gIGhhbmRsZU1vdXNlTW92ZTogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHZvaWRcbiAgaGFuZGxlTW91c2VVcDogKCkgPT4gdm9pZFxuICBzZXRQb3NpdGlvbjogKHBvczogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmFnQW5kRHJvcChcbiAgc2NhbGU6IG51bWJlcixcbiAgb25UZXh0QmxvY2tVcGRhdGU/OiAoYmxvY2s6IFRleHRCbG9jaykgPT4gdm9pZFxuKTogRHJhZ0FuZERyb3BIb29rIHtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtkcmFnU3RhcnQsIHNldERyYWdTdGFydF0gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSlcbiAgY29uc3QgW3Bvc2l0aW9uLCBzZXRQb3NpdGlvbl0gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSlcbiAgY29uc3QgW2RyYWdTdGFydFBvcywgc2V0RHJhZ1N0YXJ0UG9zXSA9IHVzZVN0YXRlKHsgeDogMCwgeTogMCB9KVxuICBjb25zdCBbZWxlbWVudFN0YXJ0UG9zLCBzZXRFbGVtZW50U3RhcnRQb3NdID0gdXNlU3RhdGUoeyB4OiAwLCB5OiAwIH0pXG4gIGNvbnN0IFthY3RpdmVCbG9jaywgc2V0QWN0aXZlQmxvY2tdID0gdXNlU3RhdGU8VGV4dEJsb2NrIHwgbnVsbD4obnVsbClcblxuICBjb25zdCBoYW5kbGVNb3VzZURvd24gPSB1c2VDYWxsYmFjaygoZTogUmVhY3QuTW91c2VFdmVudCwgYmxvY2s6IFRleHRCbG9jayB8IG51bGwpID0+IHtcbiAgICBpZiAoZS5idXR0b24gPT09IDEgfHwgKGUuYnV0dG9uID09PSAwICYmIGUuYWx0S2V5KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBzZXRJc0RyYWdnaW5nKHRydWUpXG4gICAgICBzZXREcmFnU3RhcnQoeyB4OiBlLmNsaWVudFggLSBwb3NpdGlvbi54LCB5OiBlLmNsaWVudFkgLSBwb3NpdGlvbi55IH0pXG4gICAgfSBlbHNlIGlmIChibG9jaykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBzZXRBY3RpdmVCbG9jayhibG9jaylcbiAgICAgIHNldERyYWdTdGFydFBvcyh7IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZIH0pXG4gICAgICBzZXRFbGVtZW50U3RhcnRQb3MoeyB4OiBibG9jay54LCB5OiBibG9jay55IH0pXG4gICAgfVxuICB9LCBbcG9zaXRpb25dKVxuXG4gIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgc2V0UG9zaXRpb24oe1xuICAgICAgICB4OiBlLmNsaWVudFggLSBkcmFnU3RhcnQueCxcbiAgICAgICAgeTogZS5jbGllbnRZIC0gZHJhZ1N0YXJ0LnlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChhY3RpdmVCbG9jayAmJiBvblRleHRCbG9ja1VwZGF0ZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBjb25zdCBkZWx0YVggPSAoZS5jbGllbnRYIC0gZHJhZ1N0YXJ0UG9zLngpIC8gc2NhbGVcbiAgICAgIGNvbnN0IGRlbHRhWSA9IChlLmNsaWVudFkgLSBkcmFnU3RhcnRQb3MueSkgLyBzY2FsZVxuXG4gICAgICBvblRleHRCbG9ja1VwZGF0ZSh7XG4gICAgICAgIC4uLmFjdGl2ZUJsb2NrLFxuICAgICAgICB4OiBlbGVtZW50U3RhcnRQb3MueCArIGRlbHRhWCxcbiAgICAgICAgeTogZWxlbWVudFN0YXJ0UG9zLnkgKyBkZWx0YVlcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbaXNEcmFnZ2luZywgZHJhZ1N0YXJ0LCBhY3RpdmVCbG9jaywgZHJhZ1N0YXJ0UG9zLCBlbGVtZW50U3RhcnRQb3MsIHNjYWxlLCBvblRleHRCbG9ja1VwZGF0ZV0pXG5cbiAgY29uc3QgaGFuZGxlTW91c2VVcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKVxuICAgIHNldEFjdGl2ZUJsb2NrKG51bGwpXG4gIH0sIFtdKVxuXG4gIHJldHVybiB7XG4gICAgc3RhdGU6IHtcbiAgICAgIGlzRHJhZ2dpbmcsXG4gICAgICBkcmFnU3RhcnQsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGRyYWdTdGFydFBvcyxcbiAgICAgIGVsZW1lbnRTdGFydFBvc1xuICAgIH0sXG4gICAgaGFuZGxlTW91c2VEb3duLFxuICAgIGhhbmRsZU1vdXNlTW92ZSxcbiAgICBoYW5kbGVNb3VzZVVwLFxuICAgIHNldFBvc2l0aW9uXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRHJhZ0FuZERyb3AiLCJzY2FsZSIsIm9uVGV4dEJsb2NrVXBkYXRlIiwiaXNEcmFnZ2luZyIsInNldElzRHJhZ2dpbmciLCJkcmFnU3RhcnQiLCJzZXREcmFnU3RhcnQiLCJ4IiwieSIsInBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJkcmFnU3RhcnRQb3MiLCJzZXREcmFnU3RhcnRQb3MiLCJlbGVtZW50U3RhcnRQb3MiLCJzZXRFbGVtZW50U3RhcnRQb3MiLCJhY3RpdmVCbG9jayIsInNldEFjdGl2ZUJsb2NrIiwiaGFuZGxlTW91c2VEb3duIiwiZSIsImJsb2NrIiwiYnV0dG9uIiwiYWx0S2V5IiwicHJldmVudERlZmF1bHQiLCJjbGllbnRYIiwiY2xpZW50WSIsImhhbmRsZU1vdXNlTW92ZSIsImRlbHRhWCIsImRlbHRhWSIsImhhbmRsZU1vdXNlVXAiLCJzdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useDragAndDrop.ts\n"));

/***/ })

});